<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh</title>
  <meta name="keywords" content="sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh">
  <meta name="description" content="% ML estimate of Projection from corresponding 3D-2D point pairs">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../Documentation.html">Home</a> &gt;  <a href="../../Documentation.html">General-Functions</a> &gt; <a href="#">SUGR</a> &gt; <a href="Documentation.html">Projection_3D_2D</a> &gt; sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../Documentation.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="Documentation.html">Index for General-Functions\SUGR\Projection_3D_2D&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>% ML estimate of Projection from corresponding 3D-2D point pairs</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [P,sigma_0,R] = sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh(X,y,xa,T,maxiter) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% ML estimate of Projection from corresponding 3D-2D point pairs

 [P,sigma_0,R] = sugr_estimate_ml_Projection3D_2D_from_point_pairs_hnh(X,y,xa,T,maxiter)

 * X    = struct of points X.e = Nx3 matrix, X.Cee = Nx3x3 field of CovM
 * y    = struct of points y.e = Nx3 matrix, y.Cee = Nx2x2 field of CovM
 * xa   = struct/3x4-matrix, approximate value
 * T    = threshold for iteration
 * maxiter = maximal iteration

 * P = struct estimated homography
 * sigma0 = estimated sigma0
 * R = redundancy

 see Algorithm 17, p. 499,
 however internally performing conditioning/unconditioning

 Wolfgang Förstner 4/2018
 wfoerstn@uni-bonn.de

 See also <a href="sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs.html" class="code" title="function P = sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs(X,y)">sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs</a>
 <a href="sugr_ghm_cg_Projection_3D_2D_from_point_pairs.html" class="code" title="function [lr,Cr,cg,atr,btr] = sugr_ghm_cg_Projection_3D_2D_from_point_pairs(l,le,xe,C)">sugr_ghm_cg_Projection_3D_2D_from_point_pairs</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../General-Functions/Geometry/condition_Homography.html" class="code" title="function Hc = condition_Homography(H, Tl, Tr)">condition_Homography</a>	% condition Homography</li><li><a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>	% condition points, determine conditioning matrix</li><li><a href="../../../General-Functions/SUGR/General/Estimation/sugr_ghm_update_vector.html" class="code" title="function xu = sugr_ghm_update_vector(x,p)">sugr_ghm_update_vector</a>	% GHM update spherically normalized vector</li><li><a href="sugr_Projection_3D_2D.html" class="code" title="function Point_Projection_3D_2D = sugr_Projection_3D_2D(a1,a2,a3)">sugr_Projection_3D_2D</a>	% Create pose</li><li><a href="sugr_uncondition_Projection.html" class="code" title="function P = sugr_uncondition_Projection(Pc, Ml, Mr)">sugr_uncondition_Projection</a>	% Uncondition Projection</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../12-Single-View-Geometry/Demo_Projection/demo_ALG_17_estimate_Projection_3D_2D_from_point_pairs.html" class="code" title="">demo_ALG_17_estimate_Projection_3D_2D_from_point_pairs</a>	% Demo estimate 3D projection from 2D point pairs, ALG 17</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%% ML estimate of Projection from corresponding 3D-2D point pairs</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% [P,sigma_0,R] = sugr_estimate_ml_Projection3D_2D_from_point_pairs_hnh(X,y,xa,T,maxiter)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% * X    = struct of points X.e = Nx3 matrix, X.Cee = Nx3x3 field of CovM</span>
0006 <span class="comment">% * y    = struct of points y.e = Nx3 matrix, y.Cee = Nx2x2 field of CovM</span>
0007 <span class="comment">% * xa   = struct/3x4-matrix, approximate value</span>
0008 <span class="comment">% * T    = threshold for iteration</span>
0009 <span class="comment">% * maxiter = maximal iteration</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% * P = struct estimated homography</span>
0012 <span class="comment">% * sigma0 = estimated sigma0</span>
0013 <span class="comment">% * R = redundancy</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% see Algorithm 17, p. 499,</span>
0016 <span class="comment">% however internally performing conditioning/unconditioning</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Wolfgang Förstner 4/2018</span>
0019 <span class="comment">% wfoerstn@uni-bonn.de</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% See also sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs</span>
0022 <span class="comment">% sugr_ghm_cg_Projection_3D_2D_from_point_pairs</span>
0023 
0024 
0025 <a name="_sub0" href="#_subfunctions" class="code">function [P,sigma_0,R] = sugr_estimation_ml_Projection_3D_2D_from_point_pairs_hnh(X,y,xa,T,maxiter)</a>
0026 
0027 <span class="keyword">global</span> print_option_estimation
0028 <span class="keyword">global</span> plot_option
0029 
0030 <span class="comment">%% Initialization</span>
0031 U   = 11;           <span class="comment">% number of unknown parameters</span>
0032 Ng  = 2;            <span class="comment">% number of parameters per observational group</span>
0033 Nc  = size(X.e,1);  <span class="comment">% number of pairs = number of constraints</span>
0034 
0035 <span class="comment">%% condition points and approximate projection matrix</span>
0036 
0037 <span class="comment">% condition</span>
0038 [Xe,MX] = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>(X);
0039 [ye,My] = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>(y);
0040 
0041 
0042 <span class="comment">% conditioning_MX=MX</span>
0043 <span class="comment">% conditioning_My=My</span>
0044 Pc              = <a href="../../../General-Functions/Geometry/condition_Homography.html" class="code" title="function Hc = condition_Homography(H, Tl, Tr)">condition_Homography</a>(reshape(xa,3,4),My,MX);
0045 
0046 <span class="comment">% % check projection</span>
0047 <span class="comment">%  xs = (Pc*Xc.h')';</span>
0048 <span class="comment">%  xse = xs(:,1:2)./(xs(:,3)*ones(1,2));</span>
0049 <span class="comment">%  yse = ye.e;</span>
0050 <span class="comment">%  [xse-yse]</span>
0051 
0052 Pc = Pc/norm(Pc(:));
0053 xa = Pc(:);
0054 
0055 <span class="comment">%% provide data for estimation</span>
0056 le = zeros(Nc,2);
0057 lCee = zeros(Nc,2,2);
0058 <span class="keyword">for</span> n = 1:Nc
0059     le(n,:)     = ye.e(n,:);
0060     lCee(n,:,:) = squeeze(ye.Cee(n,:,:));
0061 <span class="keyword">end</span>
0062 
0063 N      = Nc * Ng;       <span class="comment">% number of observations</span>
0064 R      = N - U;         <span class="comment">% redundancy</span>
0065 <span class="keyword">if</span> R &lt; 0
0066     disp(<span class="string">'redundancy negative'</span>)
0067     <span class="keyword">return</span>
0068 <span class="keyword">end</span>;
0069 
0070 nu=0;                            <span class="comment">% Initiate iterations</span>
0071 estl = le;                       <span class="comment">% initialize estimated observations</span>
0072 
0073 <span class="keyword">if</span> isstruct(xa)                  <span class="comment">% initiate estx, estimated unknowns</span>
0074     estx = xa.P(:);
0075 <span class="keyword">else</span>
0076     estx = xa(:);
0077 <span class="keyword">end</span>
0078 
0079 
0080 s=0;                             <span class="comment">% control variable for iterations</span>
0081 residuals=zeros(Nc,Ng);          <span class="comment">% intial residuals</span>
0082 
0083 
0084 <span class="comment">%% Start iteration -------------------------------------</span>
0085 <span class="keyword">for</span> nu=1:maxiter
0086     <span class="keyword">if</span> print_option_estimation &gt; 0
0087         sprintf(<span class="string">'nu = %2'</span>,nu);
0088     <span class="keyword">end</span>
0089     C        = zeros(Nc,Ng,Ng);      <span class="comment">% covariance matrices</span>
0090     v        = zeros(Nc,Ng);         <span class="comment">% residuals</span>
0091     A        = zeros(Nc,Ng,U);       <span class="comment">% Jacobians c -&gt; x</span>
0092     W        = zeros(Nc,Ng,Ng);      <span class="comment">% Weights of constraints</span>
0093     dl       = zeros(Nc,Ng);         <span class="comment">% linearized observations</span>
0094     
0095     N_matrix = zeros(U);   <span class="comment">% normal equation matrix</span>
0096     h_vector = zeros(U,1); <span class="comment">% right hand sides</span>
0097     
0098     <span class="comment">%% Build design matrices</span>
0099     <span class="comment">% 12x11 Jacobian for xa</span>
0100     Jr     = null(xa');
0101     
0102     <span class="keyword">for</span> n=1:Nc
0103         l_n    = le(n,:)';                   <span class="comment">% get l</span>
0104         C_n    = squeeze(lCee(n,:,:));       <span class="comment">% get CovM(l)</span>
0105         <span class="comment">% approximate fitted point homogeneous/non-homogeneous</span>
0106         est_lh_n   = reshape(estx,3,4)*[Xe.e(n,:)';1];
0107         est_l_n    = est_lh_n(1:2)/est_lh_n(3);
0108         <span class="comment">% determine dl</span>
0109         dl_n   = l_n - est_l_n;       
0110         <span class="comment">% 2x3 Jacobian for c(x)</span>
0111         Jc_n     = [est_lh_n(3)*eye(2), -est_lh_n(1:2)]/est_lh_n(3)^2;
0112         <span class="comment">% 2x11 design matrix for n-th observation</span>
0113         atr_n  = Jc_n*kron([Xe.e(n,:),1],eye(3))*Jr;
0114 
0115         <span class="comment">% Store these</span>
0116         A(n,:,:)    = atr_n;                 <span class="comment">% Ng x U</span>
0117         C(n,:,:)    = C_n;                   <span class="comment">% Ng x Ng</span>
0118         dl(n,:)     = dl_n';                 <span class="comment">%  1 x Ng</span>
0119         
0120         <span class="comment">% weight of contraint</span>
0121         W(n,:,:) = inv(C_n);                   <span class="comment">% Nc x Nc</span>
0122         aW       = atr_n' * squeeze(W(n,:,:)); <span class="comment">%  U x Ng</span>
0123         
0124         <span class="comment">% normal equation system</span>
0125         N_matrix = N_matrix + aW * atr_n;    <span class="comment">% U x U</span>
0126         h_vector = h_vector + aW * dl_n;     <span class="comment">% U x 1</span>
0127         
0128     <span class="keyword">end</span>
0129     
0130             det(N_matrix);
0131             log_ev=log(abs(eig(N_matrix)));
0132     <span class="comment">%% Solve for reduced parameters of the projection matrix</span>
0133     Cxrxr    = inv(N_matrix);
0134     estx_r   = Cxrxr * h_vector;                                           <span class="comment">%#ok&lt;MINV&gt;</span>
0135     
0136             <span class="keyword">if</span> print_option_estimation &gt; 0
0137                 disp([<span class="string">'Result of estimation in iteration: '</span>,num2str(nu)]);
0138                 estimated_corr=estx_r'  
0139                 iter_maxl_minl_cond_dx=<span class="keyword">...</span>
0140                     [nu,max(log_ev),min(log_ev),<span class="keyword">...</span>
0141                     max(log_ev)-min(log_ev),max(abs(estx_r)./sqrt(diag(Cxrxr)))]   <span class="comment">%#ok&lt;NOPRT,NASGU&gt;</span>
0142             <span class="keyword">end</span>
0143     <span class="comment">% check for convergence</span>
0144     <span class="keyword">if</span> max(abs(estx_r)./sqrt(diag(Cxrxr))) &lt; T
0145         s=2;
0146     <span class="keyword">end</span>
0147     
0148     <span class="comment">%% Determine Updates</span>
0149     Omega = 0;
0150     <span class="keyword">for</span> n=1:Nc
0151         <span class="comment">% covariance matrix of observations (normalized)</span>
0152         C_n = squeeze(C(n,:,:));
0153         <span class="comment">% fitted observation</span>
0154         est_lh_n   = reshape(estx,3,4)*[Xe.e(n,:)';1];
0155         est_le_n   = est_lh_n(1:2)/est_lh_n(3);
0156         <span class="comment">% residuals</span>
0157         ver        = est_le_n - le(n,:)';
0158         <span class="comment">% sum of squared residuals</span>
0159         vvp = ver' * inv(C_n) * ver;                           <span class="comment">%#ok&lt;MINV&gt;</span>
0160         Omega = Omega + vvp;
0161         residuals(n)=vvp;
0162     <span class="keyword">end</span>
0163     
0164     sigma_0 = 1;
0165     <span class="keyword">if</span> R &gt; 0
0166         sigma_0 = sqrt(Omega/R);
0167     <span class="keyword">end</span>
0168     <span class="keyword">if</span> print_option_estimation &gt; 0
0169         sigma_0                                                            <span class="comment">%#ok&lt;NOPRT&gt;</span>
0170     <span class="keyword">end</span>
0171     
0172     <span class="comment">% update estimate of x</span>
0173 <span class="comment">%     estx0 = estx;</span>
0174     estx  = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_ghm_update_vector.html" class="code" title="function xu = sugr_ghm_update_vector(x,p)">sugr_ghm_update_vector</a>(estx,estx_r);
0175     <span class="comment">%estx'</span>
0176     <span class="comment">% check A' W v = 0</span>
0177     check = zeros(U,1);
0178     <span class="keyword">for</span> n=1:Nc
0179         check = check <span class="keyword">...</span>
0180             + squeeze(A(n,:,:))'*inv( squeeze(C(n,:,:)))*dl(n,:)';
0181     <span class="keyword">end</span>
0182     check_cg = check';
0183     
0184     
0185     <span class="comment">%% Stop iteration</span>
0186     <span class="keyword">if</span> s == 2
0187         <span class="keyword">break</span>
0188     <span class="keyword">end</span>
0189     
0190 <span class="keyword">end</span>
0191 
0192 <span class="keyword">if</span> plot_option == -1
0193     figure(2)
0194     hold on
0195     plot(1:nu,log(conv),<span class="string">'bo-'</span>)
0196 <span class="keyword">end</span>
0197 <span class="comment">%% Evaluation of result ------------------------------</span>
0198 
0199 <span class="comment">% log_condition_number_conditioned=...</span>
0200 <span class="comment">%     max(log_ev)-min(log_ev);</span>
0201 
0202 <span class="comment">% determine Cxx</span>
0203 Jrh = null(estx');
0204 Cxx= Jrh * Cxrxr * Jrh';                                                   <span class="comment">%#ok&lt;MINV&gt;</span>
0205 
0206 <span class="comment">% determine sigma_0</span>
0207 
0208 <span class="keyword">if</span> R &gt; 0
0209     sigma_0 = sqrt(Omega/R);
0210 <span class="keyword">else</span>
0211     sigma_0 = 1;
0212 <span class="keyword">end</span>
0213 
0214 <span class="comment">% set output, still conditioned</span>
0215 Pce = reshape(estx,3,4);
0216 Pc  = <a href="sugr_Projection_3D_2D.html" class="code" title="function Point_Projection_3D_2D = sugr_Projection_3D_2D(a1,a2,a3)">sugr_Projection_3D_2D</a>(Pce,Cxx);
0217 
0218 <span class="comment">%% uncondition projection matrix</span>
0219 P = <a href="sugr_uncondition_Projection.html" class="code" title="function P = sugr_uncondition_Projection(Pc, Ml, Mr)">sugr_uncondition_Projection</a>(Pc,My,MX);
0220</pre></div>
<hr><address>Generated on Sat 21-Jul-2018 20:56:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>