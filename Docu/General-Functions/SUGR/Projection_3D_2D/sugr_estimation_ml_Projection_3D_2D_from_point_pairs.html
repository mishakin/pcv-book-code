<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of sugr_estimation_ml_Projection_3D_2D_from_point_pairs</title>
  <meta name="keywords" content="sugr_estimation_ml_Projection_3D_2D_from_point_pairs">
  <meta name="description" content="% ML estimate of Projection from corresponding 3D-2D point pairs">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../Documentation.html">Home</a> &gt;  <a href="../../Documentation.html">General-Functions</a> &gt; <a href="#">SUGR</a> &gt; <a href="Documentation.html">Projection_3D_2D</a> &gt; sugr_estimation_ml_Projection_3D_2D_from_point_pairs.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../Documentation.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="Documentation.html">Index for General-Functions\SUGR\Projection_3D_2D&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>sugr_estimation_ml_Projection_3D_2D_from_point_pairs
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>% ML estimate of Projection from corresponding 3D-2D point pairs</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [P,sigma_0,R] = sugr_estimation_ml_Projection_3D_2D_from_point_pairs(X,y,xa,T,maxiter) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% ML estimate of Projection from corresponding 3D-2D point pairs

 [P,sigma_0,R] = sugr_estimate_ml_Projection3D_2D_from_point_pairs(X,y,xa,T,maxiter)

 * X    = struct of points X.e = Nx3 matrix, X.Cee = Nx3x3 field of CovM
 * y    = struct of points y.e = Nx3 matrix, y.Cee = Nx2x2 field of CovM
 * xa   = struct/3x4-matrix, approximate value
 * T    = threshold for iteration
 * maxiter = maximal iteration

 * P = struct estimated homography
 * sigma0 = estimated sigma0
 * R = redundancy

 see Algorithm 17, p. 499,
 however, 
 - internally performing conditioning/unconditioning
 - allowing for uncertain scene coordinates

 Wolfgang Förstner 6/2017
 wfoerstn@uni-bonn.de

 See also <a href="sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs.html" class="code" title="function P = sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs(X,y)">sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs</a>
 <a href="sugr_ghm_cg_Projection_3D_2D_from_point_pairs.html" class="code" title="function [lr,Cr,cg,atr,btr] = sugr_ghm_cg_Projection_3D_2D_from_point_pairs(l,le,xe,C)">sugr_ghm_cg_Projection_3D_2D_from_point_pairs</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../General-Functions/Geometry/condition_Homography.html" class="code" title="function Hc = condition_Homography(H, Tl, Tr)">condition_Homography</a>	% condition Homography</li><li><a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>	% condition points, determine conditioning matrix</li><li><a href="../../../General-Functions/SUGR/General/Estimation/sugr_ghm_update_vector.html" class="code" title="function xu = sugr_ghm_update_vector(x,p)">sugr_ghm_update_vector</a>	% GHM update spherically normalized vector</li><li><a href="sugr_Projection_3D_2D.html" class="code" title="function Point_Projection_3D_2D = sugr_Projection_3D_2D(a1,a2,a3)">sugr_Projection_3D_2D</a>	% Create pose</li><li><a href="sugr_ghm_cg_Projection_3D_2D_from_point_pairs.html" class="code" title="function [lr,Cr,cg,atr,btr] = sugr_ghm_cg_Projection_3D_2D_from_point_pairs(l,le,xe,C)">sugr_ghm_cg_Projection_3D_2D_from_point_pairs</a>	% Determines residuals etc. for projection from point pairs</li><li><a href="sugr_uncondition_Projection.html" class="code" title="function P = sugr_uncondition_Projection(Pc, Ml, Mr)">sugr_uncondition_Projection</a>	% Uncondition Projection</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../12-Single-View-Geometry/Demo_Projection/demo_estimate_Projection_3D_2D_from_point_pairs_single.html" class="code" title="">demo_estimate_Projection_3D_2D_from_point_pairs_single</a>	% Demo estimate 3D projection from 2D point pairs</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%% ML estimate of Projection from corresponding 3D-2D point pairs</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% [P,sigma_0,R] = sugr_estimate_ml_Projection3D_2D_from_point_pairs(X,y,xa,T,maxiter)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% * X    = struct of points X.e = Nx3 matrix, X.Cee = Nx3x3 field of CovM</span>
0006 <span class="comment">% * y    = struct of points y.e = Nx3 matrix, y.Cee = Nx2x2 field of CovM</span>
0007 <span class="comment">% * xa   = struct/3x4-matrix, approximate value</span>
0008 <span class="comment">% * T    = threshold for iteration</span>
0009 <span class="comment">% * maxiter = maximal iteration</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% * P = struct estimated homography</span>
0012 <span class="comment">% * sigma0 = estimated sigma0</span>
0013 <span class="comment">% * R = redundancy</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% see Algorithm 17, p. 499,</span>
0016 <span class="comment">% however,</span>
0017 <span class="comment">% - internally performing conditioning/unconditioning</span>
0018 <span class="comment">% - allowing for uncertain scene coordinates</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Wolfgang Förstner 6/2017</span>
0021 <span class="comment">% wfoerstn@uni-bonn.de</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% See also sugr_estimation_algebraic_Projection_3D_2D_from_point_pairs</span>
0024 <span class="comment">% sugr_ghm_cg_Projection_3D_2D_from_point_pairs</span>
0025 
0026 
0027 <a name="_sub0" href="#_subfunctions" class="code">function [P,sigma_0,R] = sugr_estimation_ml_Projection_3D_2D_from_point_pairs(X,y,xa,T,maxiter)</a>
0028 
0029 <span class="keyword">global</span> print_option_estimation
0030 <span class="keyword">global</span> plot_option
0031 
0032 <span class="comment">%% Initialization</span>
0033 U   = 11;           <span class="comment">% number of unknown parameters</span>
0034 <span class="comment">% Nl  = 6;            % number of parameters per observational group (4+2)</span>
0035 Nlr = 5;            <span class="comment">% number of reduced parameters per observational group</span>
0036 Gc  = 2;            <span class="comment">% number of constraints per observational group</span>
0037 Nc  = size(X.e,1);  <span class="comment">% number of pairs</span>
0038 
0039 <span class="comment">%% condition points and approximate projection matrix</span>
0040 
0041 <span class="comment">% condition</span>
0042 [Xc,MX] = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>(X);
0043 [ye,My] = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_condition_Points.html" class="code" title="function [xc,M] = sugr_condition_Points(x)">sugr_condition_Points</a>(y);
0044 <span class="comment">% [Xc.h,10^6*reshape(Xc.Crr,Nc,9)];</span>
0045 <span class="comment">% [ye.e,10^6*reshape(ye.Cee,Nc,4)];</span>
0046 
0047 
0048 <span class="comment">% conditioning_MX=MX</span>
0049 <span class="comment">% conditioning_My=My</span>
0050 Pc              = <a href="../../../General-Functions/Geometry/condition_Homography.html" class="code" title="function Hc = condition_Homography(H, Tl, Tr)">condition_Homography</a>(reshape(xa,3,4),My,MX);
0051 
0052 <span class="comment">% % check projection</span>
0053 <span class="comment">%  xs = (Pc*Xc.h')';</span>
0054 <span class="comment">%  xse = xs(:,1:2)./(xs(:,3)*ones(1,2));</span>
0055 <span class="comment">%  yse = ye.e;</span>
0056 <span class="comment">%  [xse-yse]</span>
0057 
0058 Pc = Pc/norm(Pc(:));
0059 xa = Pc(:);
0060 
0061 <span class="comment">%% provide data for estimation</span>
0062 lh = zeros(Nc,6);
0063 lCrr = zeros(Nc,5,5);
0064 <span class="keyword">for</span> n = 1:Nc
0065     lh(n,:)     = [Xc.h(n,:),ye.e(n,:)];
0066     lCrr(n,:,:) = [squeeze(Xc.Crr(n,:,:)) zeros(3,2); <span class="keyword">...</span>
0067         zeros(2,3) squeeze(ye.Cee(n,:,:))];
0068 <span class="keyword">end</span>
0069 
0070 G      = Nc * Gc;       <span class="comment">% number of constraints</span>
0071 R      = G - U;         <span class="comment">% redundancy</span>
0072 <span class="keyword">if</span> R &lt; 0
0073     disp(<span class="string">'redundancy negative'</span>)
0074     <span class="keyword">return</span>
0075 <span class="keyword">end</span>;
0076 
0077 nu=0;                            <span class="comment">% Initiate iterations</span>
0078 estl = lh;                       <span class="comment">% initialize estimated observations</span>
0079 w_f  = ones(Nc,1);               <span class="comment">% initial weights for robust estimate</span>
0080 
0081 <span class="keyword">if</span> isstruct(xa)                  <span class="comment">% initiate estx, estimated unknowns</span>
0082     estx = xa.P(:);
0083 <span class="keyword">else</span>
0084     estx = xa(:);
0085 <span class="keyword">end</span>
0086 
0087 
0088 s=0;                             <span class="comment">% control variable for iterations</span>
0089 residuals=zeros(Nc,Gc);          <span class="comment">% intial residuals</span>
0090 
0091 
0092 <span class="comment">%% Start iteration -------------------------------------</span>
0093 <span class="keyword">for</span> nu=1:maxiter
0094     <span class="keyword">if</span> print_option_estimation &gt; 0
0095         sprintf(<span class="string">'nu = %2'</span>,nu);
0096     <span class="keyword">end</span>
0097     Cr       = zeros(Nc,Nlr,Nlr);    <span class="comment">% reduced covariance matrices</span>
0098     v_r      = zeros(Nc,Nlr);        <span class="comment">% reduced residuals</span>
0099     A        = zeros(Nc,Gc,U);       <span class="comment">% Jacobians c -&gt; x</span>
0100     B        = zeros(Nc,Gc,Nlr);     <span class="comment">% Jacobians c -&gt; l</span>
0101     W        = zeros(Nc,Gc,Gc);      <span class="comment">% Weights of constraints</span>
0102     cg       = zeros(Nc,Gc);         <span class="comment">% constraint's residuals</span>
0103     
0104     N_matrix = zeros(U);   <span class="comment">% normal equation matrix</span>
0105     h_vector = zeros(U,1); <span class="comment">% right hand sides</span>
0106     
0107     <span class="comment">%% Build design matrices</span>
0108     <span class="keyword">for</span> n=1:Nc
0109         estl_n = estl(n,:)';                 <span class="comment">% get estl</span>
0110         l_n    = lh(n,:)';                   <span class="comment">% get l</span>
0111         Crr_n  = squeeze(lCrr(n,:,:));
0112         <span class="comment">% determine cg and Jacobians (checked)</span>
0113         [lr_n,Cr_n,cg_n,atr_n,btr_n] = <span class="keyword">...</span>
0114             <a href="sugr_ghm_cg_Projection_3D_2D_from_point_pairs.html" class="code" title="function [lr,Cr,cg,atr,btr] = sugr_ghm_cg_Projection_3D_2D_from_point_pairs(l,le,xe,C)">sugr_ghm_cg_Projection_3D_2D_from_point_pairs</a>(l_n,estl_n,estx,Crr_n);
0115         <span class="comment">%cg_n'</span>
0116         
0117         <span class="comment">% Store these</span>
0118         A(n,:,:)    = atr_n;                 <span class="comment">% Gc x U</span>
0119         B(n,:,:)    = btr_n;                 <span class="comment">% Gc x Nlr</span>
0120         Cr(n,:,:)   = Cr_n;                  <span class="comment">% Nlr x Nlr</span>
0121         v_r(n,:)    = -lr_n';                <span class="comment">% 1 x Nlr</span>
0122         cg(n,:)     = cg_n';                 <span class="comment">% 1 x Gc</span>
0123         
0124         <span class="comment">% weight of contraint</span>
0125         bCovb_n  = btr_n * Cr_n * btr_n';      <span class="comment">% Gc x Gc</span>
0126         W(n,:,:) = inv(bCovb_n) * w_f(n);      <span class="comment">%#ok&lt;MINV&gt; % Gc x Gc</span>
0127         aW       = atr_n' * squeeze(W(n,:,:)); <span class="comment">% U x Gc</span>
0128         
0129         N_matrix = N_matrix + aW * atr_n;    <span class="comment">% U x U</span>
0130         h_vector = h_vector + aW * cg_n;     <span class="comment">% U x 1</span>
0131         
0132     <span class="keyword">end</span>
0133     
0134     det(N_matrix);
0135     log_ev=log(abs(eig(N_matrix)));
0136     <span class="comment">%% Solve</span>
0137     Cxrxr    = inv(N_matrix);
0138     estx_r   = Cxrxr * h_vector;                                           <span class="comment">%#ok&lt;MINV&gt;</span>
0139     
0140     <span class="keyword">if</span> print_option_estimation &gt; 0
0141         disp([<span class="string">'Result of estimation in iteration: '</span>,num2str(nu)]);
0142         estimated_corr=estx_r'                                             <span class="comment">%#ok&lt;NOPRT,NASGU&gt;</span>
0143     <span class="keyword">end</span>
0144     
0145 <span class="comment">%     iter_converg=[nu,max(abs(estx_r)./sqrt(diag(Cxrxr)))];</span>
0146     
0147     <span class="keyword">if</span> print_option_estimation &gt; 0
0148         iter_maxl_minl_cond_dx=<span class="keyword">...</span>
0149             [nu,max(log_ev),min(log_ev),<span class="keyword">...</span>
0150             max(log_ev)-min(log_ev),max(abs(estx_r)./sqrt(diag(Cxrxr)))]   <span class="comment">%#ok&lt;NOPRT,NASGU&gt;</span>
0151     <span class="keyword">end</span>
0152 <span class="comment">%     conv(nu)=max(abs(estx_r)./sqrt(diag(Cxrxr)));</span>
0153     
0154     <span class="keyword">if</span> max(abs(estx_r)./sqrt(diag(Cxrxr))) &lt; T
0155         s=2;
0156     <span class="keyword">end</span>
0157     
0158     <span class="comment">%% Determine Updates</span>
0159     Omega = 0;
0160     check = zeros(Gc,1);
0161     <span class="keyword">for</span> n=1:Nc
0162         <span class="comment">% covariance matrix of observations (normalized)</span>
0163         Clrlr = squeeze(Cr(n,:,:));
0164         
0165         <span class="comment">% corrections of reduced observations</span>
0166         delta_l_r   = Clrlr * squeeze(B(n,:,:))' * squeeze(W(n,:,:)) <span class="keyword">...</span>
0167             * (cg(n,:)'-squeeze(A(n,:,:))*estx_r)- v_r(n,:)';
0168         ver_r       = v_r(n,:)' + delta_l_r;
0169         
0170         <span class="comment">% sum of squared residuals</span>
0171         <span class="keyword">if</span> w_f(n) &gt; 0
0172             vvp_r = ver_r' * inv(Clrlr) * ver_r;                           <span class="comment">%#ok&lt;MINV&gt;</span>
0173             Omega = Omega + vvp_r;
0174             residuals(n)=vvp_r;
0175             
0176             <span class="comment">% eliminate observation by setting w_f=0 (robust version)</span>
0177             <span class="comment">%             if vvp_r &gt; 10</span>
0178             <span class="comment">%                 w_f(n)=0;</span>
0179             <span class="comment">%             end</span>
0180         <span class="keyword">end</span>
0181         <span class="comment">% updated estimates of both points</span>
0182         estl(n,1:4) = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_ghm_update_vector.html" class="code" title="function xu = sugr_ghm_update_vector(x,p)">sugr_ghm_update_vector</a>(estl(n,1:4)',delta_l_r(1:3))';
0183         estl(n,5:6) = estl(n,5:6) + delta_l_r(4:5)';
0184         
0185     <span class="keyword">end</span>
0186     
0187     sigma_0 = 1;
0188     <span class="keyword">if</span> R &gt; 0
0189         sigma_0 = sqrt(Omega/R);
0190     <span class="keyword">end</span>
0191     <span class="keyword">if</span> print_option_estimation &gt; 0
0192         sigma_0                                                            <span class="comment">%#ok&lt;NOPRT&gt;</span>
0193     <span class="keyword">end</span>
0194     
0195     <span class="comment">% update estimate of x</span>
0196 <span class="comment">%     estx0 = estx;</span>
0197     estx  = <a href="../../../General-Functions/SUGR/General/Estimation/sugr_ghm_update_vector.html" class="code" title="function xu = sugr_ghm_update_vector(x,p)">sugr_ghm_update_vector</a>(estx,estx_r);
0198     <span class="comment">%estx'</span>
0199     <span class="comment">% check</span>
0200     <span class="keyword">for</span> n=1:Nc
0201         Jl = [null(estl(n,1:4))  zeros(4,2)       ; <span class="keyword">...</span>
0202             zeros(2,3)         eye(2)];
0203         check = check <span class="keyword">...</span>
0204             + squeeze(A(n,:,:))*null(estx')'*estx(:) <span class="keyword">...</span>
0205             + squeeze(B(n,:,:))*Jl'*estl(n,:)';
0206     <span class="keyword">end</span>
0207 <span class="comment">%     check_cg = check';</span>
0208     
0209     
0210     <span class="comment">%% Stop iteration</span>
0211     <span class="keyword">if</span> s == 2
0212         <span class="keyword">break</span>
0213     <span class="keyword">end</span>
0214     
0215 <span class="keyword">end</span>
0216 
0217 <span class="keyword">if</span> plot_option == -1
0218     figure(2)
0219     hold on
0220     plot(1:nu,log(conv),<span class="string">'bo-'</span>)
0221 <span class="keyword">end</span>
0222 <span class="comment">%% Evaluation of result ------------------------------</span>
0223 
0224 <span class="comment">% log_condition_number_conditioned=...</span>
0225 <span class="comment">%     max(log_ev)-min(log_ev);</span>
0226 
0227 <span class="comment">% determine Cxx</span>
0228 Jrh = null(estx');
0229 Cxx= Jrh * Cxrxr * Jrh';                                                   <span class="comment">%#ok&lt;MINV&gt;</span>
0230 
0231 <span class="comment">% determine sigma_0</span>
0232 
0233 <span class="keyword">if</span> R &gt; 0
0234     sigma_0 = sqrt(Omega/R);
0235 <span class="keyword">else</span>
0236     sigma_0 = 1;
0237 <span class="keyword">end</span>
0238 
0239 <span class="comment">% set output, still conditioned</span>
0240 Pce = reshape(estx,3,4);
0241 Pc  = <a href="sugr_Projection_3D_2D.html" class="code" title="function Point_Projection_3D_2D = sugr_Projection_3D_2D(a1,a2,a3)">sugr_Projection_3D_2D</a>(Pce,Cxx);
0242 
0243 <span class="comment">%% uncondition projection matrix</span>
0244 P = <a href="sugr_uncondition_Projection.html" class="code" title="function P = sugr_uncondition_Projection(Pc, Ml, Mr)">sugr_uncondition_Projection</a>(Pc,My,MX);
0245</pre></div>
<hr><address>Generated on Sat 21-Jul-2018 20:56:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>